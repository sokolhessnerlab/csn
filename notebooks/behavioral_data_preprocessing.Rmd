---
title: "Behavioral Data Preprocessing"
author: "Ari Dyckovsky"
---

```{r, setup, include=FALSE}
# Knitr options
knitr::opts_chunk$set(
  warning = FALSE,
  message = FALSE,
  #echo = FALSE,
  strip.white = TRUE,
  highlight = TRUE
)

options(knitr.table.format = "markdown")

# Load packages
library(tidyverse)
library(broom)
library(gtsummary)
library(targets)
library(here)
library(withr)
library(lme4)
library(lmerTest) # adds useful info to lme4 output

# R options
options(
  width = 90
)
```


## Load extracted behavioral data 

Use `tar_load` to get the target objects per participant using the `tidyselect` syntax `starts_with` and load each object into a new environment `envir`. Then, convert the environment to a list and map each into a dataframe that binds rows of each participant's data together. This `combined_df` will include _all_ participants and include an `id` column to identify the participant individually.

```{r load-data}
withr::with_dir(here::here(), {
  combined_df <- tar_read(extracted_behavioral_data_combined)
})

# Transform step and response types to 0 or 1 integer values to simulate boolean behavior.
combined_df <- combined_df %>%
  mutate(
    is_signal = as.integer(step_type > 1),
    is_response = as.integer(resp_type)
  ) %>%
  select(-c(resp_type, step_type))
```

## Sanity checks

Count of participants by unique id.

```{r}
length(unique(combined_df$id))
```

```{r}
combined_df %>%
  select(trial, id, is_response, is_signal, resp_time, step_time) %>%
  group_by(id) %>%
  tally(is_response) %>%
  summarise(mean(n), sd(n), min(n), max(n))
```

## Combined hits dataframe for all participants

The function to get each participant's hit times vector is `itrackvalr::get_hit_times`, and the function to get a dataframe of all participants' hits is `itrackvalr::get_all_hits_with_reaction_times`, including each hit time and reaction time between that hit time and the nearest signal prompting a response within a fixed interval.

Get the combined hits using the function:

```{r}
combined_hits_df <- get_all_hits_with_reaction_times(participants, combined_df)
```

## Check out a quick preview of the table of hits

```{r}
knitr::kable(head(combined_hits_df, 10))
```

## Check out the reaction time summary statistics by id:

```{r}
knitr::kable(head(
  combined_hits_df %>%
    drop_na() %>%
    group_by(id) %>%
    summarise(
      reaction_time_mean = mean(reaction_time),
      reaction_time_min = min(reaction_time),
      reaction_time_max = max(reaction_time),
      reaction_time_sd = sd(reaction_time)
    ),
  10
))
```

## Gut-check plot of reaction times by signal times

Note the 1.000s to 1.100s gap where hits were not recorded.

```{r}
combined_hits_df %>%
  drop_na() %>%
  ggplot(aes(x = signal_time, y = reaction_time)) +
    geom_point(color = 'orange') +
    geom_smooth(method=lm) +
    theme_classic()
```

## Reaction times per participant centered at the median

```{r, fig.height = 10, fig.width = 10}
combined_hits_df %>%
  drop_na() %>%
  arrange(reaction_time) %>%
  ggplot(aes(x = reorder(id, reaction_time, FUN = median), y = reaction_time)) +
    geom_point(alpha = 0.8, size = 0.7, color = 'darkblue', position = 'jitter') +
    geom_boxplot(alpha = 0) +
    geom_hline(yintercept = 1, color = 'coral') +
  theme_minimal() +
  theme(
    aspect.ratio = 1,
    text = element_text(size = 15),
    plot.margin = margin(18, 18, 18, 18, 'pt')
  ) +
  labs(
    title = 'Reaction times of participants by id',
    subtitle = 'Boxplot per participant anchored at median of reaction time',
    y = 'Reaction time for HIT after double-tick signal',
    x = 'Participant'
  ) +
  coord_flip()
```

## Scale times to [0,1] interval for modeling

```{r}
scaled_combined_hits_df <- combined_hits_df %>%
  mutate(
    signal_time = signal_time / 3600,
    reaction_time = reaction_time
  )
```

## Predict the probability of a hit by signal time

```{r}
hit_by_signal_time_model <- function(df) {
  glmer(
    is_hit ~ 1 + signal_time + (1 | id),
    data = df,
    family = "binomial"
  )
}

model_pHit_signaltime_MFX <- hit_by_signal_time_model(scaled_combined_hits_df)

summary(model_pHit_signaltime_MFX)
```

### Predict the probability of a hit by signal time with signal time random effects

```{r}
#is_hit ~ 1 + signal_time + (1 + signal_time | id)
```

## Predict `reaction_time` using `signal_time`

```{r}
model_RT_signaltime_MFX = lmer(
  reaction_time ~ 1 + signal_time + (1 | id),
  data = scaled_combined_hits_df %>% na.omit()
)

summary(model_RT_signaltime_MFX)
```
